import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
X = pd.read_excel()
y = pd.read_excel()
def multitask_lasso(X, y, lr = 0.1, alpha = 0.01, max_iter = 100, min_gap = 0.001, normalize = False, tempotal_smooth = True):
    loss_train_record = []
    loss_dev_record = []
    weights = np.zeros((y.shape[1], X.shape[1]))
    #Set necessary factors

    if normalize == True:
        X = (X - X.mean())/X.std()
    X = np.array(X)
    y = np.array(y)
    #Data pre-processing

    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2)
    X_train, X_dev, y_train, y_dev = train_test_split(X_train, y_train, test_size = 0.3)
    # Randomly split the dataset
    H = numpy.eye(N,M=None, k=1, dtype=<type 'float'>)
    
    for iter in range(max_iter):
        if tempotal_smooth == True:
            weights = weights - lr * np.dot(np.dot(X_train, weights.T) - y_train, X_train) - 2 * lr * alpha * weights
            loss_train = np.linalg.norm(((y_train - np.dot(X_train, weights.T)) ** 2), ord=2, axis=None, keepdims=False) + np.linalg.norm((alpha * (weights ** 2)), ord=1, axis=None, keepdims=False) + np.linalg.norm((alpha*(np.dot(H.T, weights.T))), ord=1, axis=None, keepdims=False)
            loss_dev = ((y_dev - np.dot(X_dev, weights.T)) ** 2).sum(axis = 0) + alpha * (weights ** 2).sum()
            #Need to add Temporal Smoothness Prior
        else:
            weights = weights - lr * np.dot(np.dot(X_train, weights.T) - y_train, X_train) - 2 * lr * alpha * weights
            loss_train = np.linalg.norm(((y_train - np.dot(X_train, weights.T)) ** 2), ord=2, axis=None, keepdims=False) + np.linalg.norm((alpha * (weights ** 2)), ord=1, axis=None, keepdims=False) + np.linalg.norm((alpha*(np.dot(H.T, weights.T))), ord=1, axis=None, keepdims=False)
            loss_dev = ((y_dev - np.dot(X_dev, weights.T)) ** 2).sum(axis = 0) + alpha * (weights ** 2).sum()
            #Realize min ||XW−Y||^2 + θ1||W||^2
        loss_train_record.append(loss_train)
        loss_dev_record.append(loss_dev)
        if iter != 0:
            if (loss_dev_record[iter] - loss_dev_record[iter - 1]) < min_gap:
                break
    #Train the Lasso Regression
    return weights, X_test, y_test

weights, X_test, y_test = multitask_lasso(X, y, lr = 0.1, alpha = 0.01, max_iter = 100, min_gap = 0.001, normalize = False, tempotal_smooth = True)
prediction = np.dot(X_test, weights.T)
